<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>漢字マスター - Kanji Mastery</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: sans-serif;
      background: white;
      color: black;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid black;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .data-controls {
      display: flex;
      gap: 10px;
    }
    
    .data-btn {
      padding: 6px 12px;
      background: black;
      color: white;
      border: 1px solid black;
      cursor: pointer;
      font-size: 14px;
    }
    
    .data-btn:hover {
      background: #333;
    }
    
    #import-file {
      display: none;
    }
    
    h1 {
      font-size: 24px;
    }
    
    .nav-tabs {
      display: flex;
      gap: 10px;
    }
    
    .tab-btn {
      padding: 8px 16px;
      background: white;
      border: 1px solid black;
      cursor: pointer;
    }
    
    .tab-btn.active {
      background: black;
      color: white;
    }
    
    .page {
      display: none;
    }
    
    .page.active {
      display: block;
    }
    
    .legend {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      padding: 10px;
      border: 1px solid black;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border: 1px solid black;
    }
    
    .kanji-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(28px, 1fr));
      gap: 2px;
      border: 1px solid black;
      padding: 10px;
      max-height: 600px;
      overflow-y: auto;
    }
    
    .kanji-cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
      border: 1px solid #ccc;
    }
    
    .kanji-cell:hover {
      border: 2px solid black;
    }
    
    .kanji-cell.unknown { background: black; color: black; }
    .kanji-cell.learning { background: #555; color: black; }
    .kanji-cell.familiar { background: #888; color: black; }
    .kanji-cell.known { background: #bbb; color: black; }
    .kanji-cell.mastered { background: white; color: black; border: 1px solid #ccc; }
    
    /* Legend colors to match grid cells */
    .legend-color.unknown { background: black; }
    .legend-color.learning { background: #555; }
    .legend-color.familiar { background: #888; }
    .legend-color.known { background: #bbb; }
    .legend-color.mastered { background: white; border: 1px solid #ccc; }
    
    .study-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .control-group {
      min-width: 200px;
    }
    
    .control-group label {
      display: block;
      font-size: 14px;
      margin-bottom: 5px;
    }
    
    select, button {
      width: 100%;
      padding: 8px;
      border: 1px solid black;
      background: white;
      color: black;
      cursor: pointer;
    }
    
    button {
      background: black;
      color: white;
    }
    
    button:hover {
      background: #333;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .study-card {
      border: 2px solid black;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 20px;
      min-height: 400px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .kanji-display {
      font-size: 120px;
      margin-bottom: 20px;
    }
    
    .context-display {
      font-size: 32px;
      color: #666;
      margin-top: -10px;
      margin-bottom: 20px;
    }
    
    .kanji-info {
      display: none;
    }
    
    .kanji-info.visible {
      display: block;
    }
    
    .stroke-order {
      font-size: 120px;
      margin-bottom: 20px;
      min-height: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .stroke-order svg {
      width: 200px;
      height: 200px;
      display: block;
    }
    
    .reading {
      font-size: 24px;
      margin-bottom: 10px;
    }
    
    .meaning {
      font-size: 18px;
      margin-bottom: 20px;
    }
    
    .examples {
      text-align: left;
      max-width: 600px;
      margin: 0 auto;
    }
    
    .example-item {
      margin-bottom: 15px;
      padding: 10px;
      border-left: 2px solid black;
    }
    
    .example-ja {
      font-size: 16px;
      margin-bottom: 5px;
    }
    
    .example-en {
      font-size: 14px;
      color: #666;
    }
    
    .show-answer-btn {
      max-width: 300px;
    }
    
    .rating-buttons {
      display: none;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 20px;
      width: 100%;
      max-width: 600px;
    }
    
    .rating-buttons.visible {
      display: grid;
    }
    
    .rating-btn {
      padding: 10px;
      border: 2px solid black;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      border: 1px solid black;
      padding: 15px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 28px;
      font-weight: bold;
      display: block;
    }
    
    .stat-label {
      font-size: 12px;
      margin-top: 5px;
    }
    
    .no-kanji {
      text-align: center;
      padding: 40px 20px;
    }
    
    .drop-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: none;
    }
    
    .drop-overlay.active {
      display: flex;
    }
    
    .drop-message {
      color: white;
      font-size: 32px;
      font-weight: bold;
      text-align: center;
      padding: 40px;
      border: 4px dashed white;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1></h1>
      <div class="nav-tabs">
        <button class="tab-btn active" data-page="grid"></button>
        <button class="tab-btn" data-page="study"></button>
      </div>
      <div class="data-controls">
        <button class="data-btn" id="language-btn"></button>
        <button class="data-btn" id="export-btn"></button>
        <button class="data-btn" id="import-btn"></button>
        <input type="file" id="import-file" accept=".json">
      </div>
    </header>
    
    <!-- Grid Page -->
    <div id="grid-page" class="page active">
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: black"></div>
          <span></span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #555"></div>
          <span></span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #888"></div>
          <span></span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #bbb"></div>
          <span></span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: white"></div>
          <span></span>
        </div>
      </div>
      
      <div class="stats">
        <div class="stat-card">
          <span class="stat-value" id="total-kanji">0</span>
          <span class="stat-label" id="stat-total"></span>
        </div>
        <div class="stat-card">
          <span class="stat-value" id="mastered-count">0</span>
          <span class="stat-label" id="stat-mastered"></span>
        </div>
        <div class="stat-card">
          <span class="stat-value" id="learning-count">0</span>
          <span class="stat-label" id="stat-progress"></span>
        </div>
        <div class="stat-card">
          <span class="stat-value" id="unknown-count">0</span>
          <span class="stat-label" id="stat-unknown"></span>
        </div>
      </div>
      
      <div class="kanji-grid" id="kanji-grid"></div>
    </div>
    
    <!-- Study Page -->
    <div id="study-page" class="page">
      <div class="study-controls">
        <div class="control-group">
          <label id="label-filter"></label>
          <select id="level-filter" onchange="app.startStudy()">
            <option value="all" id="filter-all"></option>
            <option value="unknown" id="filter-unknown"></option>
            <option value="learning" id="filter-learning"></option>
            <option value="familiar" id="filter-familiar"></option>
            <option value="known" id="filter-known"></option>
            <option value="review" id="filter-review"></option>
          </select>
        </div>
        <div class="control-group">
          <label id="label-sort"></label>
          <select id="sort-option" onchange="app.startStudy()">
            <option value="random" id="sort-random"></option>
            <option value="frequency" id="sort-frequency"></option>
            <option value="level" id="sort-level"></option>
          </select>
        </div>
      </div>
      
      <div class="study-card" id="study-card">
        <div class="study-options" style="margin-bottom: 20px;">
          <label style="margin-right: 15px; cursor: pointer;" id="label-kun">
            <input type="checkbox" id="show-kun" checked onchange="app.saveTogglePreferences(); app.updateDisplay()">
          </label>
          <label style="margin-right: 15px; cursor: pointer;" id="label-on">
            <input type="checkbox" id="show-on" checked onchange="app.saveTogglePreferences(); app.updateDisplay()">
          </label>
          <label style="margin-right: 15px; cursor: pointer;" id="label-meaning">
            <input type="checkbox" id="show-meaning" checked onchange="app.saveTogglePreferences(); app.updateDisplay()">
          </label>
          <label style="margin-right: 15px; cursor: pointer;" id="label-examples">
            <input type="checkbox" id="show-examples" onchange="app.saveTogglePreferences(); app.updateDisplay()">
          </label>
          <label style="margin-right: 15px; cursor: pointer;" id="label-stroke">
            <input type="checkbox" id="show-stroke-order" onchange="app.saveTogglePreferences(); app.updateDisplay()">
          </label>
          <label style="cursor: pointer;" id="label-context">
            <input type="checkbox" id="show-in-context" onchange="app.saveTogglePreferences(); app.updateContextDisplay()">
          </label>
        </div>
        
        <div class="kanji-display" id="current-kanji"></div>
        <div class="context-display" id="context-display" style="display: none;"></div>
        <div class="stroke-order" id="stroke-order" style="display: none;"></div>
        
        <button class="show-answer-btn" id="show-answer-btn" onclick="app.showAnswer()">
        </button>
        
        <div class="kanji-info" id="kanji-info">
          <div class="reading" id="kanji-reading"></div>
          <div class="meaning" id="kanji-meaning"></div>
          <div class="examples" id="kanji-examples"></div>
        </div>
        
        <div class="rating-buttons" id="rating-buttons">
          <button class="rating-btn" data-rating="0" onclick="app.rateCard(0)">
            <span id="rating-again"></span><br><small id="rating-learning"></small>
          </button>
          <button class="rating-btn" data-rating="1" onclick="app.rateCard(1)">
            <span id="rating-hard"></span><br><small id="rating-familiar"></small>
          </button>
          <button class="rating-btn" data-rating="2" onclick="app.rateCard(2)">
            <span id="rating-good"></span><br><small id="rating-known"></small>
          </button>
          <button class="rating-btn" data-rating="3" onclick="app.rateCard(3)">
            <span id="rating-easy"></span><br><small id="rating-mastered"></small>
          </button>
        </div>
      </div>
      
      <div class="no-kanji" id="no-kanji" style="display: none;">
        <p id="no-kanji-msg"></p>
        <p style="margin-top: 1rem;" id="no-kanji-hint"></p>
      </div>
    </div>
  </div>
  
  <div class="drop-overlay" id="drop-overlay">
    <div class="drop-message">
    </div>
  </div>

  <script>
    const KANJI_LIST = `一二仁三四五伍六七八九十百千万萬億憶兆眺銚挑跳零令冷鈴玲齢歯裁年父釜母子孜孤孫爪孔了兄況弟第弔姉市妹黒紫此柴雌紺甘青晴清請精情靖静赤跡緑録禄黄横白泊柏伯拍迫舶粕口品器吸及扱級喫吹炊噴墳憤吐味未嘆喝渇呪唆嘱属呼唄吟今琴鳴唱昌晶叫赳喚換唯維咲哨号呉娯誤否舌后唇辰娠振震哲啓国図園遠団圏巻券拳回囲井耕丼固個困囚日旧旭曜昨酢作詐映英央暗闇暁尭曙署暑諸暖昇升弁景京影易是書音響郷香晋替暫斬田男胃異累塁畳思留画町丁頂訂庁略酪絡落畔半伴判卑碑鬼魔醜塊魂魏魅魁曲典豊目眼限瞳童瞬睡垂眠民睦県自鼻買罪罰羅罷覇覆腹複復省少炒小看督貝贈曽僧層増憎財才材賭敗賠培倍陪販反板坂飯阪版片貯賄賊購溝構講貧費貴貨化花靴革賃貸代袋賀加架嘉貿賛質賢堅員題願頑顔彦額類須頻歩順預予野頭豆逗顕顧雇月勝脚却胴腰要腕胎台怠膳善膨脂旨指胸臓蔵腸騰胞包泡抱砲飽肥豚肝干汗幹刊胆担脇脅協肺脳悩脈膜服脱肌机飢背肯骨腎火灯災燃然焼炉燥操藻繰煩爆暴煙畑畠水氷湯浩沈枕洋羊洲州酬海悔毎沖中仲忠灘波破流琉硫瀬頼渦禍鍋過洪湾浦補捕輔蒲舗浜兵潟臼興港湖胡沢択泥池地也淀河可何荷川滝竜龍渓鶏浮漏泌秘必滴摘適敵没潜浸侵寝深汚濯洗先溶容浴欲漱涼浄淳潤滑漬温沸湧勇油由汽気汁滋慈磁治渋湿涙戻泣酒潔決演淑叔液混昆濃農満両円漠濁激活括乱辞幸報測則側津漢汎凡帆渡度準滞帯済斉剤添派漫慢滅法去漂票標浅銭践漸渕淵源原減涯消肖渉澄登注柱駐漆沙砂淡談炎泳永詠凝准酸酷告酵孝教老醸壌嬢譲配酔粋木林森樋検験剣険桃逃松訟公榎樺華椿杉桜桧檜椎楢槙真慎柿梨桂圭楠根痕橘桑栃栗榊梅李柳楊揚陽槻規樹析枢枠梁棚朋崩杜槽曹遭樽橋喬僑矯欄蘭村核格各閣客械戒概慨棋期其箕旗欺杯不枚機幾磯畿枯古姑故校交較絞効郊朽極権植殖様棒奉俸桟札柄病模朴条柔集染査枝支社祈祖狙組粗租阻神申伸紳禅戦祝礼福副幅祥詳祐右祉止視初被皮彼披疲裕襟禁袖裸金銀銅同洞桐筒錫鉄迭鋼綱岡剛鉛沿鏡境錦銃充鎖釧鎌針鋭鈍屯鋳寿錠定鍵建健鉢本当鍛段鐘銘名鑑監艦釣鎮土売声喜塾熟壁癖型刑形瓶瓦墨塗墜堕有垣塀屏併壇塚塔搭答城成誠盛坑抗航堀屈掘堤提堰埼奇寄騎崎堺界場域壊懐堪勘甚均埋塩理里現珍珠朱株殊瑞班環還球求救琢王皇望聖玉素毒奏泰麦麹秦着美養姜帳長張幌晃光帽冒人傾頃佳使史借昔錯惜働動休傍任妊荏伝転催信仏払修倫輪伏位優憂傑俊駿峻体俣傷像象債佐左差俗谷俺奄僕撲業価係系件候供共他低抵底邸偵貞禎倒到俳排輩俵表備便偽為値置直依衣伊倭委仰偶遇隅例似以偏遍編篇仮住倶具償賞停亭偉違緯僚遼寮療侮仕士恭在存後行往主役疫術律循盾衛徒走超趙越赴微衝徹撤徳得征正証症政整徐叙除衡御卸街女妃姫臣臨媛援娘嫡妙妖如婿婦好媒婚姻因嫁家稼姓生星性牲産始嫌兼謙妻言誰謀某語吾悟話記己忌紀起議義犠儀論詰吉説税誌志課果菓巣詞司飼訓読訳調彫謹勤謎迷計諾診試式諮資姿次誓警敬驚護誘識織職訴認忍刃討諭愉輸癒謝射身許誕延譜普並設誇謡揺評平坪該劾諏取趣耳恥聴助聯心態能熊息恩憩恋変急忘盲忙亡患悪亜意怒奴努恐慰尉悲非扉斐想相湘箱懸悠憲懲徴懇惑愚憾感慣貫快悼怖布希惧恨惨参恒亘慌荒怪手撃投推拙出擬疑技岐携撮最掃描苗猫批比琵控捨舎掛挿擁措採菜彩掲授受拝拓押拐擦察搾握抜髪友抹末挟峡狭拡広鉱宏紘据居拠処損拷考打折挫座抑接摂扶夫捜探拾揮輝拒巨距拘足促捉躍踊用踏見親新観勧歓覧児克兜競週周近欣断辺刀速束疎運遊遅逆込入通痛途余斜遷逝巡遣送返退造逸遮追遂達進避逮迅逓迎述透選巽遺辻方肪坊妨訪房芳紡防放於族旅施旋北南西東凍棟車軌軸軟軽径茎経軒轄割舟船艇廷庭丹春夏秋萩冬朝潮乾乙韓午昼晩夜雨雲曇雰分紛粉霧務矛霞暇露路雷電雪霊需愛妥熱蒸承煮者煕照昭沼招紹召勲薫黙無舞点門問間簡関閑聞開閉閲悦閥伐闘写与冗冠軍穴字宗示寛宰辛執寒寂宮呂宝密審実窮宣寧害宅託宋寡室官菅管館阜宴賓富冨宜宇天宙抽安案完元翫寅丸究突窃切窒窪窯窓空学覚栄営蛍労掌堂党常哀衰喪裏裂列烈装壮荘製制褒保呆襲卒率豪亮享亨育棄向尚挙誉奮奈奔奪寸耐対封辱尊導道首尋裁載栽圧威灰厄歴暦厚厘席床麻摩磨廊郎朗庫府付符店商康慶庸鷹腐肉廉庶序廃発庵応廟鹿麗痢利疾痴知智虎虚戯虜慮膚盧虐劇屋局尻尾梶毛尿届展履尽尼戸所肩扇合含命企全傘寺時持侍詩待特等魚漁鯨鮮虫蛇蚊蝶融独狼浪良狂猛孟狩守猟猪獅師帥獲穫猶犯猿獄馬駒句駆区欧殴駅騒駄太烏鳥鳩鵬鴻鴈鴨鵜鶴鷲就島嶋嶌牛牟乳物事牧雄離雑難雀羽習翌翼翔翻番藩幡翁茨苑芽牙雅葉芝之乏草早卓芦芭巴把琶蕉茶菌菊葵藍薮蓮連芥介葛菩荻茅蘇菱募慕若暮墓幕蓄畜芸藝葬死薩薦薬楽夢藤茂薄博縛専簿苫占苦糸緒著績責積統給緩納内総聡純絹綿線泉網縄結締帝約的縁継絶色終紙氏紋文斎粛絵会綾繊細続縦従糾縮宿練索緊繁竹築筑篠笹世笛篤筋節即笑算筆肇籍策範米料斗粒笠立端糖唐粧庄粘糧量私稚稔念穏隠和移程呈稲穂恵秒称秩失科種重稿高季秀乃釈尺石礎礁焦研砕確硬更碁基山仙崔岩巌厳敢岸炭峠上下岳丘嶽峰峯逢縫嶺領嵐風凧岬甲崇皿盆盤磐搬般盗盟明益血衆食飲飾餓我既大臭尖奥奨将契犬献状獣力幼勉免励勢劣夕外残殉旬多久工項功攻巧江紅虹貢欠歌款隷敏改敷散数致至赦敦角触解争負危亀医矢短匠匹匿凶函幽刷剰乗創倉剖別削刈劉刻刺帰殺穀殻殿毅又収双隻隣来陣隆降際祭隊随髄院陵稜陸階皆陛陰陶陳障章彰隔陥邦鄭都郡君群部郵邪郁那郭阿弓引弘強弾単弦玄幻弥弱印再卵丈互鼓武飛冊缶弊幣面前`.split('');

    const translations = {
      ja: {
        title: '漢字マスター',
        gridView: 'グリッド表示',
        studyMode: '学習モード',
        exportData: 'データ出力',
        importData: 'データ入力',
        unknown: '未学習',
        learning: '学習中',
        familiar: '慣れた',
        known: '既知',
        mastered: '習得済み',
        allLevels: '全レベル',
        unknownOnly: '未学習のみ',
        learningOnly: '学習中のみ',
        familiarOnly: '慣れたもののみ',
        knownOnly: '既知のみ',
        reviewDue: '復習必要',
        sortBy: '並び替え',
        random: 'ランダム',
        frequency: '頻度',
        proficiency: '習熟度',
        levelFilter: 'レベルフィルター',
        kunReading: '訓読み',
        onReading: '音読み',
        meaning: '意味',
        examples: '例文',
        strokeOrder: '筆順',
        showInContext: '文脈で表示',
        showAnswer: '答えを見る',
        total: '合計',
        totalKanji: '合計漢字',
        inProgress: '学習中',
        unknownCount: '未学習',
        dataUnavailable: 'データなし',
        again: 'もう一度',
        hard: '難しい',
        good: '良い',
        easy: '簡単',
        noKanji: '選択したフィルターに該当する漢字がありません。',
        adjustFilters: 'フィルター設定を調整してください。',
        sessionComplete: '学習セッション完了！',
        selectFilter: '新しいセッションを開始するにはフィルターを選択してください。',
        noExamples: '例文はありません',
        strokeNotAvailable: '筆順データなし',
        importConfirm: '現在の進捗を置き換えます。続行しますか？',
        importSuccess: 'データが正常にインポートされました！',
        importError: 'データのインポートエラー: ',
        invalidFile: '無効なデータファイル: kanjiProgressがありません',
        dropJson: 'JSONファイルをドロップしてインポート',
        dropJsonOnly: 'JSONファイルをドロップしてください',
        clickToStudy: 'クリックして学習'
      },
      en: {
        title: 'Kanji Master',
        gridView: 'Grid View',
        studyMode: 'Study Mode',
        exportData: 'Export Data',
        importData: 'Import Data',
        unknown: 'Unknown',
        learning: 'Learning',
        familiar: 'Familiar',
        known: 'Known',
        mastered: 'Mastered',
        allLevels: 'All Levels',
        unknownOnly: 'Unknown Only',
        learningOnly: 'Learning Only',
        familiarOnly: 'Familiar Only',
        knownOnly: 'Known Only',
        reviewDue: 'Review Due',
        sortBy: 'Sort By',
        random: 'Random',
        frequency: 'Frequency',
        proficiency: 'Proficiency Level',
        levelFilter: 'Level Filter',
        kunReading: 'Kunyomi',
        onReading: 'Onyomi',
        meaning: 'Meaning',
        examples: 'Examples',
        strokeOrder: 'Stroke Order',
        showInContext: 'Show in Context',
        showAnswer: 'Show Answer',
        total: 'Total',
        totalKanji: 'Total Kanji',
        inProgress: 'In Progress',
        unknownCount: 'Unknown',
        dataUnavailable: 'Data unavailable',
        again: 'Again',
        hard: 'Hard',
        good: 'Good',
        easy: 'Easy',
        noKanji: 'No kanji available for the selected filters.',
        adjustFilters: 'Try adjusting your filter settings.',
        sessionComplete: 'Study session complete!',
        selectFilter: 'Select a filter to start a new session.',
        noExamples: 'No examples available',
        strokeNotAvailable: 'Stroke order not available',
        importConfirm: 'This will replace your current progress. Continue?',
        importSuccess: 'Data imported successfully!',
        importError: 'Error importing data: ',
        invalidFile: 'Invalid data file: missing kanjiProgress',
        dropJson: 'Drop JSON file to import',
        dropJsonOnly: 'Please drop a JSON file',
        clickToStudy: 'Click to study'
      }
    };

    const app = {
      kanjiData: {},
      currentKanji: null,
      studyQueue: [],
      currentIndex: 0,
      currentKanjiFullData: null,
      nextKanjiData: null, // Cache for pre-fetched next card
      language: 'ja',
      
      init() {
        this.loadLanguage();
        this.loadData();
        this.loadTogglePreferences();
        this.setupEventListeners();
        this.renderGrid();
        this.updateStats();
        this.applyTranslations();
      },
      
      loadLanguage() {
        const saved = localStorage.getItem('language');
        if (saved) {
          this.language = saved;
        }
      },
      
      toggleLanguage() {
        this.language = this.language === 'ja' ? 'en' : 'ja';
        localStorage.setItem('language', this.language);
        document.getElementById('language-btn').textContent = this.language === 'ja' ? 'EN' : '日本語';
        this.applyTranslations();
        this.renderGrid(); // Re-render grid to update tooltips
      },
      
      t(key) {
        return translations[this.language][key] || key;
      },
      
      applyTranslations() {
        // Header
        document.querySelector('h1').textContent = this.t('title');
        document.querySelectorAll('.tab-btn')[0].textContent = this.t('gridView');
        document.querySelectorAll('.tab-btn')[1].textContent = this.t('studyMode');
        document.getElementById('language-btn').textContent = this.language === 'ja' ? 'EN' : '日本語';
        document.getElementById('export-btn').textContent = this.t('exportData');
        document.getElementById('import-btn').textContent = this.t('importData');
        
        // Legend
        const legendItems = document.querySelectorAll('.legend-item span');
        legendItems[0].textContent = this.t('unknown');
        legendItems[1].textContent = this.t('learning');
        legendItems[2].textContent = this.t('familiar');
        legendItems[3].textContent = this.t('known');
        legendItems[4].textContent = this.t('mastered');
        
        // Study labels
        document.getElementById('label-filter').textContent = this.t('levelFilter');
        document.getElementById('label-sort').textContent = this.t('sortBy');
        
        // Sort options
        document.getElementById('sort-random').textContent = this.t('random');
        document.getElementById('sort-frequency').textContent = this.t('frequency');
        document.getElementById('sort-level').textContent = this.t('proficiency');
        
        // Checkbox labels - need to preserve the checkbox input
        const kunCheckbox = document.getElementById('show-kun');
        const onCheckbox = document.getElementById('show-on');
        const meaningCheckbox = document.getElementById('show-meaning');
        const examplesCheckbox = document.getElementById('show-examples');
        const strokeCheckbox = document.getElementById('show-stroke-order');
        
        document.getElementById('label-kun').innerHTML = `<input type="checkbox" id="show-kun" ${kunCheckbox.checked ? 'checked' : ''} onchange="app.saveTogglePreferences(); app.updateDisplay()"> ${this.t('kunReading')}`;
        document.getElementById('label-on').innerHTML = `<input type="checkbox" id="show-on" ${onCheckbox.checked ? 'checked' : ''} onchange="app.saveTogglePreferences(); app.updateDisplay()"> ${this.t('onReading')}`;
        document.getElementById('label-meaning').innerHTML = `<input type="checkbox" id="show-meaning" ${meaningCheckbox.checked ? 'checked' : ''} onchange="app.saveTogglePreferences(); app.updateDisplay()"> ${this.t('meaning')}`;
        document.getElementById('label-examples').innerHTML = `<input type="checkbox" id="show-examples" ${examplesCheckbox.checked ? 'checked' : ''} onchange="app.saveTogglePreferences(); app.updateDisplay()"> ${this.t('examples')}`;
        document.getElementById('label-stroke').innerHTML = `<input type="checkbox" id="show-stroke-order" ${strokeCheckbox.checked ? 'checked' : ''} onchange="app.saveTogglePreferences(); app.updateDisplay()"> ${this.t('strokeOrder')}`;
        
        const contextCheckbox = document.getElementById('show-in-context');
        document.getElementById('label-context').innerHTML = `<input type="checkbox" id="show-in-context" ${contextCheckbox.checked ? 'checked' : ''} onchange="app.saveTogglePreferences(); app.updateContextDisplay()"> ${this.t('showInContext')}`;
        
        // Show answer button
        document.getElementById('show-answer-btn').textContent = this.t('showAnswer');
        
        // Stats
        document.getElementById('stat-total').textContent = this.t('totalKanji');
        document.getElementById('stat-mastered').textContent = this.t('mastered');
        document.getElementById('stat-progress').textContent = this.t('inProgress');
        document.getElementById('stat-unknown').textContent = this.t('unknownCount');
        
        // Rating buttons
        document.getElementById('rating-again').textContent = this.t('again');
        document.getElementById('rating-hard').textContent = this.t('hard');
        document.getElementById('rating-good').textContent = this.t('good');
        document.getElementById('rating-easy').textContent = this.t('easy');
        document.getElementById('rating-learning').textContent = this.t('learning');
        document.getElementById('rating-familiar').textContent = this.t('familiar');
        document.getElementById('rating-known').textContent = this.t('known');
        document.getElementById('rating-mastered').textContent = this.t('mastered');
        
        // Update filter counts to use current language
        this.updateFilterCounts();
        
        // No kanji messages
        document.getElementById('no-kanji-msg').textContent = this.t('noKanji');
        document.getElementById('no-kanji-hint').textContent = this.t('adjustFilters');
        
        // Drop overlay
        document.querySelector('.drop-message').textContent = this.t('dropJson');
      },
      
      loadTogglePreferences() {
        const prefs = localStorage.getItem('togglePreferences');
        if (prefs) {
          const preferences = JSON.parse(prefs);
          document.getElementById('show-kun').checked = preferences.showKun ?? true;
          document.getElementById('show-on').checked = preferences.showOn ?? true;
          document.getElementById('show-meaning').checked = preferences.showMeaning ?? true;
          document.getElementById('show-examples').checked = preferences.showExamples ?? false;
          document.getElementById('show-stroke-order').checked = preferences.showStrokeOrder ?? false;
          document.getElementById('show-in-context').checked = preferences.showInContext ?? false;
        } else {
          // Set defaults
          document.getElementById('show-kun').checked = true;
          document.getElementById('show-on').checked = true;
          document.getElementById('show-meaning').checked = true;
          document.getElementById('show-examples').checked = false;
          document.getElementById('show-stroke-order').checked = false;
          document.getElementById('show-in-context').checked = false;
        }
      },
      
      saveTogglePreferences() {
        const preferences = {
          showKun: document.getElementById('show-kun').checked,
          showOn: document.getElementById('show-on').checked,
          showMeaning: document.getElementById('show-meaning').checked,
          showExamples: document.getElementById('show-examples').checked,
          showStrokeOrder: document.getElementById('show-stroke-order').checked,
          showInContext: document.getElementById('show-in-context').checked
        };
        localStorage.setItem('togglePreferences', JSON.stringify(preferences));
      },
      
      loadData() {
        const saved = localStorage.getItem('kanjiProgress');
        if (saved) {
          this.kanjiData = JSON.parse(saved);
        } else {
          // Initialize all kanji as unknown
          KANJI_LIST.forEach(kanji => {
            this.kanjiData[kanji] = {
              level: 0, // 0=unknown, 1=learning, 2=familiar, 3=known, 4=mastered
              lastReview: null,
              nextReview: null,
              reviewCount: 0
            };
          });
          this.saveData();
        }
      },
      
      saveData() {
        localStorage.setItem('kanjiProgress', JSON.stringify(this.kanjiData));
      },
      
      exportData() {
        const data = {
          kanjiProgress: this.kanjiData,
          togglePreferences: JSON.parse(localStorage.getItem('togglePreferences') || '{}'),
          exportDate: new Date().toISOString(),
          version: '1.0'
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `kanji-progress-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },
      
      importData(file) {
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            
            // Validate the data structure
            if (!data.kanjiProgress) {
              alert(this.t('invalidFile'));
              return;
            }
            
            // Confirm before overwriting
            if (!confirm(this.t('importConfirm'))) {
              return;
            }
            
            // Import the data
            this.kanjiData = data.kanjiProgress;
            this.saveData();
            
            // Import preferences if they exist
            if (data.togglePreferences) {
              localStorage.setItem('togglePreferences', JSON.stringify(data.togglePreferences));
              this.loadTogglePreferences();
            }
            
            // Refresh the display
            this.renderGrid();
            this.updateStats();
            
            alert(this.t('importSuccess'));
          } catch (error) {
            alert(this.t('importError') + error.message);
          }
          
          // Reset the file input
          document.getElementById('import-file').value = '';
        };
        
        reader.readAsText(file);
      },
      
      setupEventListeners() {
        // Language button
        document.getElementById('language-btn').addEventListener('click', () => {
          this.toggleLanguage();
        });
        
        // Export/Import buttons
        document.getElementById('export-btn').addEventListener('click', () => {
          this.exportData();
        });
        
        document.getElementById('import-btn').addEventListener('click', () => {
          document.getElementById('import-file').click();
        });
        
        document.getElementById('import-file').addEventListener('change', (e) => {
          this.importData(e.target.files[0]);
        });
        
        // Drag and drop
        let dragCounter = 0;
        const overlay = document.getElementById('drop-overlay');
        
        document.addEventListener('dragenter', (e) => {
          e.preventDefault();
          dragCounter++;
          if (dragCounter === 1) {
            overlay.classList.add('active');
          }
        });
        
        document.addEventListener('dragleave', (e) => {
          e.preventDefault();
          dragCounter--;
          if (dragCounter === 0) {
            overlay.classList.remove('active');
          }
        });
        
        document.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        
        document.addEventListener('drop', (e) => {
          e.preventDefault();
          dragCounter = 0;
          overlay.classList.remove('active');
          
          const files = e.dataTransfer.files;
          if (files.length > 0) {
            const file = files[0];
            if (file.type === 'application/json' || file.name.endsWith('.json')) {
              this.importData(file);
            } else {
              alert(this.t('dropJsonOnly'));
            }
          }
        });
        
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            e.target.classList.add('active');
            const page = e.target.dataset.page;
            document.getElementById(page + '-page').classList.add('active');
            
            // Auto-start study when switching to study page
            if (page === 'study') {
              this.startStudy();
            }
          });
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          // Ignore if typing in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          
          const key = e.key.toLowerCase();
          const isAnswerVisible = document.getElementById('kanji-info').classList.contains('visible');
          const isStudyMode = document.getElementById('study-page').classList.contains('active');
          
          // Only handle shortcuts in study mode
          if (!isStudyMode) return;
          
          // Space/Enter - Show Answer
          if ((key === ' ' || key === 'enter') && !isAnswerVisible) {
            e.preventDefault();
            this.showAnswer();
            return;
          }
          
          // Number keys 0-4 - Rate cards (only when answer is visible)
          if (isAnswerVisible && ['0', '1', '2', '3', '4'].includes(key)) {
            e.preventDefault();
            const rating = parseInt(key);
            this.rateCard(rating);
            return;
          }
          
          // Toggle shortcuts (work anytime in study mode)
          if (key === 'k') {
            e.preventDefault();
            document.getElementById('show-kun').click();
            return;
          }
          if (key === 'o') {
            e.preventDefault();
            document.getElementById('show-on').click();
            return;
          }
          if (key === 'm') {
            e.preventDefault();
            document.getElementById('show-meaning').click();
            return;
          }
          if (key === 'e') {
            e.preventDefault();
            document.getElementById('show-examples').click();
            return;
          }
          if (key === 's') {
            e.preventDefault();
            document.getElementById('show-stroke-order').click();
            return;
          }
          
          // Arrow keys / Backspace - Navigate cards
          if (key === 'arrowleft' || key === 'backspace') {
            e.preventDefault();
            this.previousCard();
            return;
          }
          if (key === 'arrowright') {
            e.preventDefault();
            this.nextCard();
            return;
          }
          
          // R - Restart session
          if (key === 'r') {
            e.preventDefault();
            this.startStudy();
            return;
          }
          
          // Escape - Skip card
          if (key === 'escape') {
            e.preventDefault();
            this.skipCard();
            return;
          }
        });
      },
      
      renderGrid() {
        const grid = document.getElementById('kanji-grid');
        grid.innerHTML = '';
        
        KANJI_LIST.forEach(kanji => {
          const cell = document.createElement('div');
          cell.className = 'kanji-cell ' + this.getLevelClass(kanji);
          cell.textContent = kanji;
          cell.title = `${this.t('clickToStudy')}: ${kanji}`;
          cell.addEventListener('click', () => this.studySpecificKanji(kanji));
          grid.appendChild(cell);
        });
      },
      
      studySpecificKanji(kanji) {
        // Switch to study mode tab
        this.switchTab('study');
        
        // Create a study queue with just this kanji
        this.studyQueue = [kanji];
        this.currentIndex = 0;
        
        // Show study card
        document.getElementById('study-card').style.display = 'flex';
        document.getElementById('no-kanji').style.display = 'none';
        
        // Load the card
        this.showCard();
      },
      
      switchTab(page) {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.classList.remove('active');
          if (btn.dataset.page === page) {
            btn.classList.add('active');
          }
        });
        
        // Update pages
        document.querySelectorAll('.page').forEach(p => {
          p.classList.remove('active');
        });
        document.getElementById(page + '-page').classList.add('active');
      },
      
      getLevelClass(kanji) {
        const level = this.kanjiData[kanji]?.level || 0;
        const classes = ['unknown', 'learning', 'familiar', 'known', 'mastered'];
        return classes[level];
      },
      
      updateStats() {
        const stats = { unknown: 0, learning: 0, familiar: 0, known: 0, mastered: 0 };
        KANJI_LIST.forEach(kanji => {
          const level = this.kanjiData[kanji]?.level || 0;
          const key = ['unknown', 'learning', 'familiar', 'known', 'mastered'][level];
          stats[key]++;
        });
        
        document.getElementById('total-kanji').textContent = KANJI_LIST.length;
        document.getElementById('mastered-count').textContent = stats.mastered;
        document.getElementById('learning-count').textContent = stats.learning + stats.familiar + stats.known;
        document.getElementById('unknown-count').textContent = stats.unknown;
        
        // Update filter counts
        this.updateFilterCounts();
      },
      
      updateFilterCounts() {
        const now = new Date();
        
        // Count cards for each filter
        const counts = {
          all: KANJI_LIST.length,
          unknown: 0,
          learning: 0,
          familiar: 0,
          known: 0,
          review: 0
        };
        
        KANJI_LIST.forEach(kanji => {
          const data = this.kanjiData[kanji] || { level: 0, lastReview: null, nextReview: null, reviewCount: 0 };
          
          if (data.level === 0) counts.unknown++;
          if (data.level === 1) counts.learning++;
          if (data.level === 2) counts.familiar++;
          if (data.level === 3) counts.known++;
          
          // Count review due
          if (data.nextReview && new Date(data.nextReview) <= now) {
            counts.review++;
          }
        });
        
        // Update option text with counts using translations
        document.getElementById('filter-all').textContent = `${this.t('allLevels')} (${counts.all})`;
        document.getElementById('filter-unknown').textContent = `${this.t('unknownOnly')} (${counts.unknown})`;
        document.getElementById('filter-learning').textContent = `${this.t('learningOnly')} (${counts.learning})`;
        document.getElementById('filter-familiar').textContent = `${this.t('familiarOnly')} (${counts.familiar})`;
        document.getElementById('filter-known').textContent = `${this.t('knownOnly')} (${counts.known})`;
        document.getElementById('filter-review').textContent = `${this.t('reviewDue')} (${counts.review})`;
      },
      
      
      async startStudy() {
        const filter = document.getElementById('level-filter').value;
        const sort = document.getElementById('sort-option').value;
        
        const now = new Date();
        
        // Build queue based on filter
        this.studyQueue = KANJI_LIST.filter(kanji => {
          const data = this.kanjiData[kanji] || { level: 0, lastReview: null, nextReview: null, reviewCount: 0 };
          
          // First check the level filter
          if (filter === 'all') return true;
          if (filter === 'unknown') return data.level === 0;
          if (filter === 'learning') return data.level === 1;
          if (filter === 'familiar') return data.level === 2;
          if (filter === 'known') return data.level === 3;
          if (filter === 'review') {
            // Only show cards that are due for review
            if (!data.nextReview) return false;
            return new Date(data.nextReview) <= now;
          }
          return false;
        });
        
        if (this.studyQueue.length === 0) {
          document.getElementById('study-card').style.display = 'none';
          document.getElementById('no-kanji').style.display = 'block';
          return;
        }
        
        document.getElementById('study-card').style.display = 'flex';
        document.getElementById('no-kanji').style.display = 'none';
        
        // Sort queue
        if (sort === 'random') {
          this.studyQueue.sort(() => Math.random() - 0.5);
        } else if (sort === 'level') {
          this.studyQueue.sort((a, b) => this.kanjiData[a].level - this.kanjiData[b].level);
        }
        // For frequency, we'll keep the original order (which is roughly by frequency)
        
        this.currentIndex = 0;
        this.showCard();
      },
      
      async preFetchNextCard() {
        // Pre-fetch data for the next card in background
        const nextIndex = this.currentIndex + 1;
        if (nextIndex >= this.studyQueue.length) {
          // No next card to pre-fetch
          this.nextKanjiData = null;
          return;
        }
        
        const nextKanji = this.studyQueue[nextIndex];
        console.log('Pre-fetching data for next card:', nextKanji);
        
        try {
          // Fetch both APIs in parallel
          const [kanjiResponse, wordsResponse] = await Promise.all([
            fetch(`https://kanjiapi.dev/v1/kanji/${nextKanji}`),
            fetch(`https://kanjiapi.dev/v1/words/${nextKanji}`)
          ]);
          
          const kanjiData = await kanjiResponse.json();
          const wordsData = await wordsResponse.json();
          kanjiData.words = wordsData;
          
          this.nextKanjiData = {
            kanji: nextKanji,
            data: kanjiData
          };
          console.log('Pre-fetch complete for:', nextKanji);
        } catch (error) {
          console.error('Error pre-fetching next card:', error);
          this.nextKanjiData = null;
        }
      },
      
      async showCard() {
        if (this.currentIndex >= this.studyQueue.length) {
          // Session complete - just hide the card
          document.getElementById('study-card').style.display = 'none';
          document.getElementById('no-kanji').style.display = 'block';
          document.getElementById('no-kanji').innerHTML = `<p>${this.t('sessionComplete')}</p><p style="margin-top: 1rem;">${this.t('selectFilter')}</p>`;
          return;
        }
        
        this.currentKanji = this.studyQueue[this.currentIndex];
        
        // Check if we have pre-fetched data for this card
        if (this.nextKanjiData && this.nextKanjiData.kanji === this.currentKanji) {
          console.log('Using pre-fetched data for:', this.currentKanji);
          this.currentKanjiFullData = this.nextKanjiData.data;
          this.nextKanjiData = null; // Clear the cache
          
          // Display kanji with optional context
          this.updateContextDisplay();
        } else {
          // No cached data, fetch it now
          console.log('Fetching data for:', this.currentKanji);
          try {
            // Fetch both APIs in parallel
            const [kanjiResponse, wordsResponse] = await Promise.all([
              fetch(`https://kanjiapi.dev/v1/kanji/${this.currentKanji}`),
              fetch(`https://kanjiapi.dev/v1/words/${this.currentKanji}`)
            ]);
            
            const kanjiData = await kanjiResponse.json();
            const wordsData = await wordsResponse.json();
            this.currentKanjiFullData = kanjiData;
            this.currentKanjiFullData.words = wordsData;
            
            // Display kanji with optional context
            this.updateContextDisplay();
            
          } catch (error) {
            console.error('Error fetching kanji data:', error);
            this.currentKanjiFullData = null;
            document.getElementById('current-kanji').textContent = this.currentKanji;
            document.getElementById('context-display').style.display = 'none';
          }
        }
        
        // Reset UI state
        document.getElementById('kanji-info').classList.remove('visible');
        document.getElementById('rating-buttons').classList.remove('visible');
        document.getElementById('show-answer-btn').style.display = 'block';
        
        // Reset display - show kanji, hide stroke order initially
        document.getElementById('current-kanji').style.display = 'block';
        document.getElementById('stroke-order').style.display = 'none';
        document.getElementById('stroke-order').innerHTML = '';
        
        // Pre-fetch the NEXT card in background
        this.preFetchNextCard();
      },
      
      displayAnswer() {
        const data = this.currentKanjiFullData;
        
        if (!data) {
          document.getElementById('kanji-reading').textContent = '—';
          document.getElementById('kanji-meaning').textContent = this.t('dataUnavailable');
          document.getElementById('kanji-examples').innerHTML = '';
          return;
        }
        
        const showKun = document.getElementById('show-kun').checked;
        const showOn = document.getElementById('show-on').checked;
        const showMeaning = document.getElementById('show-meaning').checked;
        const showExamples = document.getElementById('show-examples').checked;
        const showStrokeOrder = document.getElementById('show-stroke-order').checked;
        
        // Toggle between kanji display and stroke order
        if (showStrokeOrder) {
          document.getElementById('current-kanji').style.display = 'none';
          document.getElementById('context-display').style.display = 'none';
          document.getElementById('stroke-order').style.display = 'block';
          this.loadStrokeOrder();
        } else {
          document.getElementById('current-kanji').style.display = 'block';
          document.getElementById('stroke-order').style.display = 'none';
          // Re-apply context display based on setting
          this.updateContextDisplay();
        }
        
        let readingHTML = '';
        
        // Show ALL kun readings if checked
        if (showKun && data.kun_readings && data.kun_readings.length > 0) {
          readingHTML += `<div style="margin-bottom: 15px;">
            <strong>訓読み:</strong> ${data.kun_readings.join(', ')}
          </div>`;
        }
        
        // Show ALL on readings if checked
        if (showOn && data.on_readings && data.on_readings.length > 0) {
          readingHTML += `<div style="margin-bottom: 15px;">
            <strong>音読み:</strong> ${data.on_readings.join(', ')}
          </div>`;
        }
        
        if (readingHTML) {
          document.getElementById('kanji-reading').innerHTML = readingHTML;
          document.getElementById('kanji-reading').style.display = 'block';
        } else {
          document.getElementById('kanji-reading').style.display = 'none';
        }
        
        // Show ALL meanings if checked
        if (showMeaning) {
          if (data.meanings && data.meanings.length > 0) {
            document.getElementById('kanji-meaning').textContent = data.meanings.join(', ');
          } else {
            document.getElementById('kanji-meaning').textContent = '—';
          }
          document.getElementById('kanji-meaning').style.display = 'block';
        } else {
          document.getElementById('kanji-meaning').style.display = 'none';
        }
        
        // Show examples if checked
        if (showExamples) {
          const examplesHTML = this.getExamples(data);
          document.getElementById('kanji-examples').innerHTML = examplesHTML;
          document.getElementById('kanji-examples').style.display = 'block';
        } else {
          document.getElementById('kanji-examples').style.display = 'none';
        }
      },
      
      async loadStrokeOrder() {
        const kanji = this.currentKanji;
        const unicode = kanji.codePointAt(0).toString(16).padStart(5, '0');
        const svgUrl = `https://raw.githubusercontent.com/KanjiVG/kanjivg/master/kanji/${unicode}.svg`;
        
        try {
          const response = await fetch(svgUrl);
          const svgText = await response.text();
          
          // Parse SVG properly to avoid XML artifacts
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
          const svg = svgDoc.querySelector('svg');
          
          if (!svg) {
            throw new Error('Invalid SVG');
          }
          
          // Clean up the container and add the SVG
          const container = document.getElementById('stroke-order');
          container.innerHTML = '';
          container.appendChild(svg.cloneNode(true));
          
          // Get the imported SVG element
          const importedSvg = container.querySelector('svg');
          
          // Remove all metadata groups (kvg:element, text elements, etc.)
          importedSvg.querySelectorAll('g[id^="kvg:StrokeNumbers"]').forEach(el => el.remove());
          importedSvg.querySelectorAll('text').forEach(el => el.remove());
          
          // Get only the stroke paths (not the character outline)
          const paths = importedSvg.querySelectorAll('path[id^="kvg:"]');
          paths.forEach((path, index) => {
            // Style the strokes
            path.style.fill = 'none';
            path.style.stroke = 'black';
            path.style.strokeWidth = '3';
            path.style.strokeLinecap = 'round';
            path.style.strokeLinejoin = 'round';
            
            // Animate
            const length = path.getTotalLength();
            path.style.strokeDasharray = length;
            path.style.strokeDashoffset = length;
            path.style.animation = `drawStroke 0.5s ease-out ${index * 0.3}s forwards`;
          });
          
          // Add CSS animation if not already added
          if (!document.getElementById('stroke-animation-style')) {
            const style = document.createElement('style');
            style.id = 'stroke-animation-style';
            style.textContent = `
              @keyframes drawStroke {
                to {
                  stroke-dashoffset: 0;
                }
              }
            `;
            document.head.appendChild(style);
          }
        } catch (error) {
          console.error('Error loading stroke order:', error);
          document.getElementById('stroke-order').innerHTML = `<p style="color: #999;">${this.t('strokeNotAvailable')}</p>`;
        }
      },
      
      getBestRepresentativeWord(kanji, data) {
        console.log('getBestRepresentativeWord called for:', kanji);
        console.log('Kanji character code:', kanji.charCodeAt(0));
        
        if (!data || !data.words || data.words.length === 0) {
          console.log('No words available, returning empty array');
          return []; // Fallback to empty
        }
        
        console.log('First few words:', data.words.slice(0, 5).map(w => w.variants[0]?.written));
        
        // IMPORTANT: Check if any words actually contain our target kanji
        const wordsWithTargetKanji = data.words.filter(word => {
          const written = word.variants[0]?.written || '';
          return written.includes(kanji);
        });
        
        console.log('Words containing target kanji:', wordsWithTargetKanji.length);
        if (wordsWithTargetKanji.length === 0) {
          console.log('NO WORDS CONTAIN TARGET KANJI - returning empty array');
          return []; // Don't show misleading context
        }
        
        const examples = [];
        
        // Priority 1: Verbal form (verb with okurigana ending in う-form)
        // Look for patterns like: 操る, 輝く, 食べる
        const verbalForms = wordsWithTargetKanji.filter(word => {
          const written = word.variants[0]?.written || '';
          if (!written.startsWith(kanji)) return false;
          if (written.length < 2 || written.length > 4) return false;
          const afterKanji = written.substring(1);
          // Must be hiragana and typically end in う-column (う, く, す, つ, ぬ, ぶ, む, る, ぐ, ず, づ, ぶ, ぷ)
          return /^[\u3040-\u309F]+$/.test(afterKanji) && 
                 /[うくすつぬぶむるぐずづぷ]$/.test(written);
        }).sort((a, b) => a.variants[0].written.length - b.variants[0].written.length);
        
        if (verbalForms.length > 0) {
          console.log('Found verbal form:', verbalForms[0].variants[0].written);
          examples.push(verbalForms[0].variants[0].written);
        }
        
        // Priority 2: Kanji compound (2-kanji word where our kanji is first)
        if (examples.length < 5) {
          const compounds = wordsWithTargetKanji.filter(word => {
            const written = word.variants[0]?.written || '';
            return written.length === 2 && 
                   written.startsWith(kanji) &&
                   !/[\u3040-\u309F]/.test(written) && // No hiragana
                   !examples.includes(written);
          });
          
          if (compounds.length > 0) {
            console.log('Found compound:', compounds[0].variants[0].written);
            examples.push(compounds[0].variants[0].written);
          }
        }
        
        // Priority 3: Adjectival form (adjective with okurigana, typically ending in い or しい)
        if (examples.length < 5) {
          const adjectivalForms = wordsWithTargetKanji.filter(word => {
            const written = word.variants[0]?.written || '';
            if (!written.startsWith(kanji)) return false;
            if (written.length < 2 || written.length > 5) return false;
            const afterKanji = written.substring(1);
            // Must be hiragana and end in い (adjective pattern)
            return /^[\u3040-\u309F]+$/.test(afterKanji) && 
                   /い$/.test(written) &&
                   !examples.includes(written);
          }).sort((a, b) => a.variants[0].written.length - b.variants[0].written.length);
          
          if (adjectivalForms.length > 0) {
            console.log('Found adjectival form:', adjectivalForms[0].variants[0].written);
            examples.push(adjectivalForms[0].variants[0].written);
          }
        }
        
        // Priority 4: Adverbial form (adverb with okurigana, typically ending in り or く)
        if (examples.length < 5) {
          const adverbialForms = wordsWithTargetKanji.filter(word => {
            const written = word.variants[0]?.written || '';
            if (!written.startsWith(kanji)) return false;
            if (written.length < 2 || written.length > 5) return false;
            const afterKanji = written.substring(1);
            // Must be hiragana and end in り or く (adverb pattern)
            return /^[\u3040-\u309F]+$/.test(afterKanji) && 
                   /[りく]$/.test(written) &&
                   !examples.includes(written);
          }).sort((a, b) => a.variants[0].written.length - b.variants[0].written.length);
          
          if (adverbialForms.length > 0) {
            console.log('Found adverbial form:', adverbialForms[0].variants[0].written);
            examples.push(adverbialForms[0].variants[0].written);
          }
        }
        
        // Priority 5: Single kanji by itself (一, 二, 人)
        if (examples.length < 5) {
          const singleKanji = wordsWithTargetKanji.find(word => {
            const written = word.variants[0]?.written || '';
            return written === kanji;
          });
          if (singleKanji && !examples.includes(kanji)) {
            console.log('Found single kanji:', kanji);
            examples.push(kanji);
          }
        }
        
        console.log('Final examples:', examples);
        return examples;
      },
      
      getExamples(data) {
        if (!data.words || data.words.length === 0) {
          return `<p>${this.t('noExamples')}</p>`;
        }
        
        // Get first 3-5 examples
        const examples = data.words.slice(0, 5);
        let html = '';
        
        examples.forEach(word => {
          const meanings = word.meanings.map(m => m.glosses.join(', ')).join('; ');
          html += `
            <div class="example-item">
              <div class="example-ja">${word.variants[0].written} (${word.variants[0].pronounced})</div>
              <div class="example-en">${meanings}</div>
            </div>
          `;
        });
        
        return html;
      },
      
      showAnswer() {
        this.displayAnswer();
        document.getElementById('kanji-info').classList.add('visible');
        document.getElementById('rating-buttons').classList.add('visible');
        document.getElementById('show-answer-btn').style.display = 'none';
      },
      
      updateContextDisplay() {
        // Update the displayed kanji/word without resetting the card state
        if (!this.currentKanji || !this.currentKanjiFullData) {
          return; // No card loaded yet
        }
        
        const showInContext = document.getElementById('show-in-context').checked;
        const contextDisplay = document.getElementById('context-display');
        
        // Always show the isolated kanji
        document.getElementById('current-kanji').textContent = this.currentKanji;
        
        if (showInContext) {
          // Show context words underneath
          const contextWords = this.getBestRepresentativeWord(this.currentKanji, this.currentKanjiFullData);
          // Only show if we have context words
          if (contextWords.length > 0) {
            contextDisplay.textContent = contextWords.join('・'); // Japanese middle dot separator
            contextDisplay.style.display = 'block';
          } else {
            contextDisplay.style.display = 'none';
          }
        } else {
          // Hide context
          contextDisplay.style.display = 'none';
        }
      },
      
      updateDisplay() {
        // Only update if answer is already shown
        if (document.getElementById('kanji-info').classList.contains('visible')) {
          this.displayAnswer();
        }
      },
      
      rateCard(rating) {
        // Update kanji data
        const data = this.kanjiData[this.currentKanji];
        data.level = rating;
        data.lastReview = new Date().toISOString();
        data.reviewCount++;
        
        // Calculate next review (simple SRS)
        const intervals = [1, 3, 7, 14, 30]; // days
        const interval = intervals[rating] || 1;
        const nextReview = new Date();
        nextReview.setDate(nextReview.getDate() + interval);
        data.nextReview = nextReview.toISOString();
        
        this.saveData();
        this.renderGrid();
        this.updateStats();
        
        // Move to next card
        this.currentIndex++;
        this.showCard();
      },
      
      previousCard() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.showCard();
        }
      },
      
      nextCard() {
        if (this.currentIndex < this.studyQueue.length - 1) {
          this.currentIndex++;
          this.showCard();
        }
      },
      
      skipCard() {
        // Skip without rating
        this.currentIndex++;
        this.showCard();
      }
    };

    // Initialize app
    app.init();
  </script>
</body>
</html>
